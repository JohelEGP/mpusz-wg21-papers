<pre class='metadata'>
Title: A C++ Approach to Physical Units
Shortname: D1215
Revision: 0
Status: D
Group: WG21
Audience: SG6, LEWG
URL: https://mpusz.github.io/wg21-papers/papers/1215_a_cpp_approach_to_physical_units.html
Editor: Mateusz Pusz, Epam Systems http://www.epam.com, mateusz.pusz@gmail.com, http://www.train-it.eu
Abstract: This document starts the discussion about the Physical Units support for the
          C++ Standard Library. The reader will find here the rationale for such a library.
          After that comes the review and comparison of current solutions on the market
          followed by the analysis of the problems related to their usage and user
          experience. The rest of the document describes solutions and techniques that
          can be used to mitigate those issues. All of them were implemented and tested
          by the author in the mp-units library.
Repository: mpusz/wg21_papers
!Source: <a href="https://github.com/mpusz/wg21_papers/blob/master/src/1215_a_cpp_approach_to_physical_units.bs">github.com/mpusz/wg21_papers/blob/master/src/1215_a_cpp_approach_to_physical_units.bs</a>
Markup Shorthands: markdown on
</pre>


Introduction {#introduction}
============================

Overview {#overview}
--------------------

Human history knows many expensive failures and accidents caused by mistakes in
calculations involving different physical units. The most famous and probably the most
expensive example in the software engineering domain is the Mars Climate Orbiter that in
1999 failed to enter Mars orbit and crashed while entering its atmosphere [[MARS_ORBITER]].
That is not the only example here. People tend to confuse units quite often. We see similar
errors occurring in various domains over the years:
- On October 12, 1492, Christopher Columbus unintentionally discovered America because
    during his travel preparations he mixed Arabic mile with a Roman mile which led to
    the wrong estimation of the equator and his expected travel distance [[COLUMBUS]]
- Air Canada Flight 143 ran out of fuel on July 23, 1983, at an altitude of 41 000 feet
    (12 000 metres), midway through the flight because the fuel had been calculated in
    pounds instead of kilograms by the ground crew [[GIMLI_GLIDER]]
- On April 15, 1999, Korean Air Cargo Flight 6316 crashed due to the miscommunication
    between pilots about desired flight altitude [[FLIGHT_6316]]
- In February 2001 Zoo crew built an enclosure for Clarence the Tortoise with a weight of
    250 pounds instead of 250 kilograms [[CLARENCE]]
- In December 2003, one of the roller coaster's cars at Tokyo Disneyland’s Space Mountain
    attraction suddenly derailed due to a broken axle caused by the confusion after
    upgrading the specification from imperial to metric units [[DISNEY]]
- An American company sold a shipment of wild rice to a Japanese customer, quoting a price
    of 39 cents per pound, but the customer thought the quote was for 39 cents per kilogram
    [[WILD_RICE]]
- A whole set of medication dose errors...

Lack of strong types {#lack-of-strong-types}
--------------------------------------------

It turns out that in the C++ software most of our calculations in the physical units domain
are handled with fundamental types like `double`. Code like below is a typical example
here:

```cpp
double GlidePolar::MacCreadyAltitude(double emcready,
                                     double Distance,
                                     const double Bearing,
                                     const double WindSpeed,
                                     const double WindBearing,
                                     double *BestCruiseTrack,
                                     double *VMacCready,
                                     const bool isFinalGlide,
                                     double *TimeToGo,
                                     const double AltitudeAboveTarget,
                                     const double cruise_efficiency,
                                     const double TaskAltDiff);
```

Even though this example comes from an Open Source project, expensive revenue-generating
production source code often does not differ too much. We lack strong typedefs feature in the
core language, and without it, we are often too lazy to handcraft a new class type for each
use case.

The proliferation of magic numbers {#magic-numbers}
-----------------------------------------------

There are a lot of constants and conversion factors involved in the dimensional analysis.
Source code responsible for such computations is often trashed with magic numbers

```cpp
// Air Density(kg/m3) from relative humidity(%),
// temperature(°C) and absolute pressure(Pa)
double AirDensity(double hr, double temp, double abs_press)
{
  return (1/(287.06*(temp+273.15))) *
         (abs_press - 230.617 * hr * exp((17.5043*temp)/(241.2+temp)));
}
```


Motivation and Scope {#motivation-and-scope}
============================================

Motivation {#motivation}
------------------------

There is a huge demand for high-quality physical units library in the industry and
scientific environments. The code that we write for fun and living should be correct, safe,
and easy to write. Although there are multiple such libraries available on the market, none
of them is a widely accepted production standard. We could just provide a yet another 3rd
party library covering this topic, but it is probably not the best idea.

First of all, software that could benefit from such a library is not a niche in the market.
If it was the case, probably its needs could be fulfilled with a 3rd party highly-specialized
and narrow-use library. On the contrary, a broad range of production projects deals with units
conversions and dimensional analysis. Right now, having no other reasonable and easy to access
alternatives results in the proliferation of plain `double` type usage to express physical
quantities. Space, aviation, automotive, embedded, scientific, computer science, and many
other domains could benefit from strong types and conversions provided by such a library.

Secondly, yet another library will not solve the issue for many customers. Many corporations
are not allowed to use 3rd party libraries in the production code. Also, an important point
here is the cooperation of different products from multiple vendors that use physical quantities
as vocabulary types in their interfaces. From the author's experience gathered while working
with numerous corporations all over the world, there is a considerable difference between the
adoption of a mature 3rd party library and the usage of features released as a part of
the C++ Standard Library. If it were not the case all products would use Boost.Units already.
A motivating example here can be `std::chrono` released as a part of C++11. Right now, no one
asks questions on how to represent timestamps and how to handle their conversions in the code.
`std::chrono` is the ultimate answer. So let us try to get `std::units` in the C++
Standard Library too.

The Goal {#goal}
----------------

The aim of this paper is to standardize a physical units library that enables operations on
various dimensions and units:

```cpp
// simple numeric operations
static_assert(10km / 2 == 5km);

// unit conversions
static_assert(1h == 3600s);
static_assert(1km + 1m == 1001m);

// dimension conversions
static_assert(1km / 1s == 1000mps);
static_assert(2kmph * 2h == 4km);
static_assert(2km / 2kmph == 1h);

static_assert(1000 / 1s == 1kHz);

static_assert(10km / 5km == 2);
```

We intent to provide users with cleaner interfaces by using strong types and concepts in
the interfaces rather than fundamental types with a meaning described in comments or documentation:

```cpp
constexpr std::units::Velocity auto avg_speed(std::units::Length auto d, std::units::Time auto t)
{
  return d / t;
}
```

We further aim to provide unit conversion facilities and constants for users to rely on,
instead of magic numbers:

```cpp
using namespace std::units_literals;

const std::units::Velocity auto speed = avg_speed(220.km, 2.h);
std::cout << "Average speed: "
          << std::units::quantity_cast<std::units::kilometre_per_hour>(speed) << '\n';
```

Scope {#scope}
--------------

Although there is a public demand for a generic units library that could handle any units and
dimensions, the author suggests scoping the Committee efforts only on the physical and possibly
computer science (i.e. `bit`, `bitrate`) units first. The library should be designed with
easy extensibility in mind so anyone needing a new base or derived dimensions
(i.e. `coffee/milk/water/sugar` system) could achieve this with a few lines of the C++ code
(not preprocessor macros).

After releasing a first, restricted version of the library and observing how it is used we
can consider standardizing additional dimensions, units, and constants in the following
C++ releases.


Terms and definitions {#terms-and_definitions}
==============================================

ISO 80000-1:2009(E) definitions {#iso-definitions}
--------------------------------------------------

ISO 80000-1:2009(E) Quantities and units - Part 1: General
[[!ISO_80000-1]] defines among others the following terms:

<dfn>quantity</dfn>

- Property of a phenomenon, body, or substance, where the property has a magnitude that can
    be expressed by means of a number and a reference.
- A reference can be a measurement unit, a measurement procedure, a reference material, or
    a combination of such.
- A quantity as defined here is a scalar. However, a vector or a tensor, the components of
    which are quantities, is also considered to be a quantity.
- The concept ’quantity’ may be generically divided into, e.g. ‘physical quantity’,
    ‘chemical quantity’, and ‘biological quantity’, or ‘base quantity’ and ‘derived quantity’.

<dfn lt="kind of quantity|kind">kind of quantity, kind</dfn>

- Aspect common to mutually comparable [=quantities=].
- The division of the concept ‘quantity’ into several kinds is to some extent arbitrary
    - i.e. the quantities diameter, circumference, and wavelength are generally considered
        to be [=quantities=] of the same kind, namely, of the kind of quantity called length.)
- [=Quantities=] of the same kind within a given [=system of quantities=] have the same quantity
    [=dimension=]. However, [=quantities=] of the same [=dimension=] are not necessarily of
    the same kind.

<dfn lt="system of quantities|system">system of quantities, system</dfn>

- Set of [=quantities=] together with a set of non-contradictory equations relating those
    [=quantities=].

<dfn>base quantity</dfn>

- [=Quantity=] in a conventionally chosen subset of a given [=system of quantities=], where
    no [=quantity=] in the subset can be expressed in terms of the other [=quantities=]
    within that subset.
- Base quantities are referred to as being mutually independent since a base quantity
    cannot be expressed as a product of powers of the other base quantities.

<dfn>derived quantity</dfn>

- [=Quantity=], in a [=system of quantities=], defined in terms of the base quantities of
    that system

<dfn lt="International System of Quantities|ISQ">International System of Quantities (ISQ)</dfn>

- [=System of quantities=] based on the seven [=base quantities=]: length, mass, time,
    electric current, thermodynamic temperature, amount of substance, and luminous intensity.
- The International System of Units (SI) is based on the ISQ.

<dfn lt="dimension of a quantity|quantity dimension|dimension">dimension of a quantity,
quantity dimension, dimension</dfn>

- Expression of the dependence of a [=quantity=] on the [=base quantities=] of
    a [=system of quantities=] as a product of powers of factors corresponding to the [=base
    quantities=], omitting any numerical factors.
- A power of a factor is the factor raised to an exponent. Each factor is the dimension of
    a [=base quantity=].
- In deriving the dimension of a quantity, no account is taken of its scalar, vector, or
    tensor character.
- In a given [=system of quantities=]:
    - [=quantities=] of the same [=kind=] have the same quantity dimension,
    - [=quantities=] of different quantity dimensions are always of different [=kinds=],
    - [=quantities=] having the same quantity dimension are not necessarily of the same [=kind=].

<dfn lt="quantity of dimension one|quantities of dimension one|dimensionless quantity">
quantity of dimension one, dimensionless quantity</dfn>

- [=Quantity=] for which all the exponents of the factors corresponding to the
    [=base quantities=] in its [=quantity dimension=] are zero.
- The term “dimensionless quantity” is commonly used and is kept here for historical reasons.
    It stems from the fact that all exponents are zero in the symbolic representation of
    the [=dimension=] for such [=quantities=]. The term “quantity of dimension one” reflects
    the convention in which the symbolic representation of the [=dimension=] for such
    [=quantities=] is the symbol 1. This [=dimension=] is not a number, but the neutral
    element for multiplication of [=dimensions=].
- The measurement [=units=] and values of [=quantities=] of dimension one are numbers, but
    such [=quantities=] convey more information than a number.
- Some [=quantities=] of dimension one are defined as the ratios of two [=quantities=] of
    the same kind. The coherent [=derived unit=] is the number one, symbol 1.

<dfn lt="unit of measurement|measurement unit|unit">unit of measurement, measurement unit,
unit</dfn>

- Real scalar [=quantity=], defined and adopted by convention, with which any other
    [=quantity=] of the same [=kind=] can be compared to express the ratio of the second
    quantity to the first one as a number.
- Measurement units are designated by conventionally assigned names and symbols.
- Measurement units of [=quantities=] of the same [=quantity dimension=] may be designated
    by the same name and symbol even when the [=quantities=] are not of the same [=kind=].
    For example, joule per kelvin and J/K are respectively the name and symbol of both a
    measurement unit of heat capacity and a measurement unit of entropy, which are generally
    not considered to be [=quantities=] of the same [=kind=]. However, in some cases special
    measurement unit names are restricted to be used with [=quantities=] of specific kind
    only. For example, the measurement unit ‘second to the power minus one’ (1/s) is called
    hertz (Hz) when used for frequencies and becquerel (Bq) when used for activities of
    radionuclides. As another example, the joule (J) is used as a unit of energy, but never
    as a unit of moment of force, i.e. the newton metre (N · m).
- Measurement units of [=quantities of dimension one=] are numbers. In some cases, these
    measurement units are given special names, e.g. radian, steradian, and decibel, or are
    expressed by quotients such as millimole per mole equal to 10<sup>−3</sup> and microgram
    per kilogram equal to 10<sup>−9</sup>.

<dfn>base unit</dfn>

- Measurement unit that is adopted by convention for a [=base quantity=]
- In each coherent [=system of units=], there is only one base unit for each [=base quantity=].
- A base unit may also serve for a [=derived quantity=] of the same [=quantity dimension=].

<dfn>derived unit</dfn>

- Measurement unit for a [=derived quantity=]

<dfn export>coherent derived unit</dfn>

- Derived [=unit=] that, for a given [=system of quantities=] and for a chosen set of
    [=base units=], is a product of powers of [=base units=] with no other proportionality
    factor than one.
- A power of a [=base unit=] is the [=base unit=] raised to an exponent.
- Coherence can be determined only with respect to a particular [=system of quantities=]
    and a given set of [=base units=].
    - i.e. if the metre and the second are base units, the metre per second is the coherent
        derived unit of velocity.

<dfn>system of units</dfn>

- Set of [=base units=] and [=derived units=], together with their multiples and submultiples,
    defined in accordance with given rules, for a given [=system of quantities=].

<dfn lt="off-system measurement unit|off-system unit">off-system measurement unit,
off-system unit</dfn>

- [=Measurement unit=] that does not belong to a given [=system of units=].
    - i.e. the electronvolt (≈ 1,602 18 × 10–19 J) is an off-system measurement unit of energy
        with respect to the SI or day, hour, minute are off-system measurement units of time
        with respect to the SI.

<dfn lt="International System of Units|SI">International System of Units (SI)</dfn>

- [=System of units=], based on the [=International System of Quantities=], their names and
    symbols, including a series of prefixes and their names and symbols, together with rules
    for their use, adopted by the General Conference on Weights and Measures (CGPM)

<dfn>multiple of a unit</dfn>

- [=Measurement unit=] obtained by multiplying a given [=measurement unit=] by an integer
    greater than one.
- [=SI=] prefixes refer strictly to powers of 10, and should not be used for powers of 2.
    - i.e. 1 kbit should not be used to represent 1024 bits (2<sup>10</sup> bits),
        which is a kibibit (1 Kibit).

<dfn export>submultiple of a unit</dfn>

- [=Measurement unit=] obtained by dividing a given [=measurement unit=] by an integer
    greater than one.

<dfn lt="quantity value|value of a quantity|value">quantity value, value of a quantity,
value</dfn>

- Number and reference together expressing magnitude of a [=quantity=].
- A quantity value can be presented in more than one way.


Prior Work {#prior-work}
========================

There are many dimensional analysis libraries available on the market today. Some of them
are more successful than others, but none of them is a widely accepted standard in the C++
codebase (both Open Source as well as production code). The next sections of this chapter
will describe the most interesting parts of selected libraries. The last section provides
an extensive comparison of their main features.

{This chapter is incomplete and will be filled in D1215R1 that should be available as a draft
on the LEWG Wiki before Belfast meeting}

Boost.Units {#boost.units}
--------------------------

Boost.Units [[BOOST.UNITS]] is probably the most widely adopted library in this domain.
It was first released in Boost 1.36.0 that was released in 2008.

{TBD}

cppnow17-units {#cppnow17-units}
--------------------------------

Steven Watanabe, the coauthor of the previous library, started the work on the modernized
version of the library based on the results of LiaW on C++Now 2017 [[CPPNOW17-UNITS]]

{TBD}

PhysUnits-CT-Cpp11 {#PhysUnits-CT-Cpp11}
----------------------------------------

[[PHYSUNITS-CT-CPP11]]

{TBD}

Nic Holthaus units {#nic-units}
-------------------------------

The next library created by Nic Holthaus [[NIC_UNITS]] provides a dimension as
a hardcoded sequence of `std::ratio`s in a `base_unit` class template.

```cpp
namespace units {

template<class Meter = detail::meter_ratio<0>,
         class Kilogram = std::ratio<0>,
         class Second = std::ratio<0>,
         class Radian = std::ratio<0>,
         class Ampere = std::ratio<0>,
         class Kelvin = std::ratio<0>,
         class Mole = std::ratio<0>,
         class Candela = std::ratio<0>,
         class Byte = std::ratio<0>>
struct base_unit;

}
```

Unit is expressed as instantiations of the `unit` class template.

```cpp
namespace units {

template<class Conversion, class BaseUnit, class PiExponent = std::ratio<0>, class Translation = std::ratio<0>>

}
```

Important to notice here are:
- `PiExponent` - an exponent representing factors of PI required by the conversion
    (i.e. `std::ratio<-1>` for a radians to degrees conversion)
- `Translation` - a ratio representing a datum translation required for the conversion
    (i.e. `std::ratio<32>` for a Fahrenheit to Celsius conversion)

```cpp
namespace units {

template<class Units, typename T = UNIT_LIB_DEFAULT_TYPE,
         template<typename> class NonLinearScale = linear_scale>
class unit_t : public NonLinearScale<T> { ... };

}
```

Interesting to notice here is that beside typical SI dimensions, there are also `Radian`
and `Byte`.

This library also presents a different approach than previous cases. There are no dimensions
or quantity types. Every unit is an instantiation of the `unit` class template
with ratio and a specific `base_unit` responsible for unit "category". Each "dimension"
of the unit is defined in its namespace. To form a quantity, there is additional

```cpp
namespace units {

namespace category {

typedef base_unit<std::ratio<2>, std::ratio<1>, std::ratio<-3>, std::ratio<0>, std::ratio<-1>> voltage_unit;

}

namespace voltage {

typedef unit<std::ratio<1>, units::category::voltage_unit> volts;
typedef volts volt;
typedef unit_t<volt> volt_t;

}

}
```

To form a value

```cpp
#include <units.h>

using namespace units::literals;

units::voltage::volt_t v = 230_V;
```

Bryan St. Amour units {#bryan-units}
------------------------------------

[[BRYAN_UNITS]]

{TBD}

benri {#benri}
--------------

[[BENRI]]

{TBD}

Michael Ford units {#mikeford3-units}
-------------------------------------

[[MIKEFORD3_UNITS]]

{TBD}

`std::chrono::duration` {#chrono::duration}
-------------------------------------------

{TBD}

Comparison {#comparison}
------------------------

{TBD}

<!-- markdownlint-disable line-length -->
<table>
  <tr>
    <th>Feature</th><th>mp-units</th><th>Boost.Units</th><th>cppnow17-units</th><th>PhysUnits-CT-Cpp11</th><th>nholthaus</th><th>bstamour</th>
  </tr>
  <tr>
    <td>SI</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td>
  </tr>
  <tr>
    <td>Customary system</td><td>yes</td><td>yes</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td>Other systems</td><td>???</td><td>yes</td><td></td><td></td><td>yes (`bytes`, `radians`)</td><td></td>
  </tr>
  <tr>
    <td>C++ version</td><td>C++20</td><td>C++98 + `constexpr`</td><td></td><td></td><td>C++14</td><td></td>
  </tr>
  <tr>
    <td>Base dimension id</td><td>string</td><td>integer</td><td></td><td></td><td>index on template parameter list</td><td></td>
  </tr>
  <tr>
    <td>Dimension</td><td>type (`length`)</td><td>type (`length_dimension`)</td><td></td><td></td><td>none</td><td></td>
  </tr>
  <tr>
    <td>Dimension representation</td><td>type list</td><td>type list</td><td></td><td></td><td>Class template arguments</td><td></td>
  </tr>
  <tr>
    <td>Fractional exponents</td><td>yes</td><td>yes</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td>Type traits for dimensions</td><td>no</td><td>yes</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td>Unit</td><td>type (`metre`)</td><td>type + constant (`si::length` + `si::meter`)</td><td></td><td></td><td>type (`length::meter_t`)</td><td></td>
  </tr>
  <tr>
    <td>UDLs</td><td>yes</td><td>no</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td>Predefined scaled unit types</td><td>some</td><td>no</td><td></td><td></td><td>all</td><td></td>
  </tr>
  <tr>
    <td>Scaled units</td><td>type + UDL (`kilometre` + `km`)</td><td>user's type + multiply with constant (`make_scaled_unit<>` + `si::kilo * si::meter`)</td><td></td><td></td><td>type + UDL (`length::kilometer_t` + `_km`)</td><td></td>
  </tr>
  <tr>
    <td>Meter vs metre</td><td>metre</td><td>both</td><td></td><td></td><td>meter</td><td></td>
  </tr>
  <tr>
    <td>Singular vs plural</td><td>singular (`metre`)</td><td>both (`meter` + `meters`)</td><td></td><td></td><td>both (`length::meter_t` + `length::meters_t`)</td><td></td>
  </tr>
  <tr>
    <td>Quantity</td><td>type (`quantity<metre> q(2);`)</td><td>type (`quantity<si::length> q(2 * si::meter);`)</td><td></td><td></td><td>value of unit (`length::meter_t d(220);`)</td><td></td>
  </tr>
  <tr>
    <td>Literal instance</td><td>UDL (`123m`)</td><td>Number * static constant (`123 * si::meters`)</td><td></td><td></td><td>UDL (`123_m`)</td><td></td>
  </tr>
  <tr>
    <td>Variable instance</td><td>constructor (`quantity<metre>(v)`)</td><td>Variable * static constant (`d * si::meters`)</td><td></td><td></td><td>constructor (`length::meter_t(v)`)</td><td></td>
  </tr>
  <tr>
    <td>Any representation</td><td>yes</td><td>yes</td><td></td><td>no (macro to set the default type)</td><td>no (macro to set the default type)</td><td></td>
  </tr>
  <tr>
    <td>Quantity template arguments type deduction</td><td>yes</td><td>yes</td><td></td><td></td><td>no</td><td></td>
  </tr>
  <tr>
    <td>System support</td><td>no</td><td>yes</td><td></td><td></td><td>no</td><td></td>
  </tr>
  <tr>
    <td>C++ Concepts</td><td>yes</td><td>no</td><td>no</td><td>no</td><td>no</td><td>no</td>
  </tr>
  <tr>
    <td>Types downcasting</td><td>yes</td><td>no</td><td>no</td><td>no</td><td>no</td><td>no</td>
  </tr>
  <tr>
    <td>Implicit unit conversions</td><td>same dimension non-truncating only</td><td>no</td><td></td><td></td><td></td><td></td>
  </tr>
  <tr>
    <td>Explicit unit conversions</td><td>`quantity_cast`</td><td>`quantity_cast`</td><td></td><td></td><td></td><td></td>
  </tr>
  <tr>
    <td>Temperature support</td><td>Kelvins only + conversion functions</td><td>Kelvins only + dedicated systems</td><td></td><td></td><td></td><td></td>
  </tr>
  <tr>
    <td>String output</td><td>TBD</td><td>yes</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td>String input</td><td>no</td><td>no</td><td></td><td></td><td>no</td><td></td>
  </tr>
  <tr>
    <td>Macros in the user interface</td><td>no</td><td>yes</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td>Non-linear scale support</td><td>no</td><td>no</td><td></td><td></td><td>yes</td><td></td>
  </tr>
  <tr>
    <td></td><td></td><td></td><td></td><td></td><td></td><td></td>
  </tr>
</table>
<!-- markdownlint-enable line-length -->


Fundamental concerns with current solutions {#concerns}
=======================================================

Feedback from the users gathered so far signals the following significant complaints regarding
the libraries described in [[#prior-work]]:
- Bad user experience caused by hard to understand and analyze compile-time errors and poor
    debugging experience.
- Too high entry bar (e.g. Boost.Units is claimed to require expertise in both C++ and
    dimensional analysis.).
- Unnecessary intermediate [=quantity value=] conversions to [=base units=] resulting in a
    runtime overhead and loss of precision.
- Poor support for really large or small ratios (i.e. `eV`).
- Safety and security connected problems with the usage of an external 3rd party library
    for production purposes.
- Impossibility or hard extensibility of the library with new base dimensions.


Design principles {#design-principles}
======================================

(Enumerate basic design principles)

1. Safety and performance
    - strong types
    - compile-time safety
    - constexpr all the things
    - as fast or even faster than when working with fundamental types
2. The best possible user experience
    - compiler errors
    - debugging
3. No macros in the user interface
4. Easy extensibility
5. No external dependencies
6. Possibility to be standardized as a freestanding part of the C++ Standard Library

(other ideas)

- Be consistent


Improving user experience {#user-experience}
============================================

Type aliasing issues {#type-aliasing-issues}
--------------------------------------------

Type aliases benefit developers but not end-users. As a result, users end up with colossal
error messages.

Code developer works with the following syntax:

```cpp
constexpr bu::quantity<bu::si::velocity> avg_speed(bu::quantity<bu::si::length> d,
                                                   bu::quantity<bu::si::time> t)
{ return d * t; }
```

If the error happens in such a code user sees the following error for gcc-8:

<!-- markdownlint-disable line-length -->
```text
error: could not convert ‘boost::units::operator*(const boost::units::quantity<Unit1, X>&,
const boost::units::quantity<Unit2, Y>&) [with Unit1 = boost::units::unit<boost::units::list<boost::units::dim
<boost::units::length_base_dimension, boost::units::static_rational<1> >, boost::units::dimensionless_type>,
boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit,
boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10,
boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit,
boost::units::list<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit,
boost::units::list<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit,
boost::units::list<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit,
boost::units::dimensionless_type> > > > > > > > > > >; Unit2 = boost::units::unit<boost::units::list<boost::units::dim
<boost::units::time_base_dimension, boost::units::static_rational<1> >, boost::units::dimensionless_type>,
boost::units::homogeneous_system<boost::units::list<boost::units::si::meter_base_unit,
boost::units::list<boost::units::scaled_base_unit<boost::units::cgs::gram_base_unit, boost::units::scale<10,
boost::units::static_rational<3> > >, boost::units::list<boost::units::si::second_base_unit, boost::units::list
<boost::units::si::ampere_base_unit, boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list
<boost::units::si::mole_base_unit, boost::units::list<boost::units::si::candela_base_unit, boost::units::list
<boost::units::angle::radian_base_unit, boost::units::list<boost::units::angle::steradian_base_unit,
boost::units::dimensionless_type> > > > > > > > > > >; X = double; Y = double; typename
boost::units::multiply_typeof_helper<boost::units::quantity<Unit1, X>, boost::units::quantity<Unit2, Y> >::type =
boost::units::quantity<boost::units::unit<boost::units::list<boost::units::dim<boost::units::length_base_dimension,
boost::units::static_rational<1> >, boost::units::list<boost::units::dim<boost::units::time_base_dimension,
boost::units::static_rational<1> >, boost::units::dimensionless_type> >, boost::units::homogeneous_system
<boost::units::list<boost::units::si::meter_base_unit, boost::units::list<boost::units::scaled_base_unit
<boost::units::cgs::gram_base_unit, boost::units::scale<10, boost::units::static_rational<3> > >,
boost::units::list<boost::units::si::second_base_unit, boost::units::list<boost::units::si::ampere_base_unit,
boost::units::list<boost::units::si::kelvin_base_unit, boost::units::list<boost::units::si::mole_base_unit,
boost::units::list<boost::units::si::candela_base_unit, boost::units::list<boost::units::angle::radian_base_unit,
boost::units::list<boost::units::angle::steradian_base_unit, boost::units::dimensionless_type> > > > > > > > > >,
void>, double>](t)’ from ‘quantity<unit<list<[...],list<dim<[...],static_rational<1>>,[...]>>,[...],[...]>,[...]>’
to ‘quantity<unit<list<[...],list<dim<[...],static_rational<-1>>,[...]>>,[...],[...]>,[...]>’
     return d * t;
            ~~^~~
```
<!-- markdownlint-enable line-length -->

This is only the very first line of the compilation error log. The same error for clang-7
looks as follows:

<!-- markdownlint-disable line-length -->
```text
error: no viable conversion from returned value of type 'quantity<unit<list<[...], list<dim<[...],
static_rational<1, [...]>>, [...]>>, [...]>, [...]>' to function return type 'quantity<unit<list<[...], list<dim<[...],
static_rational<-1, [...]>>, [...]>>, [...]>, [...]>'
    return d * t;
           ^~~~~
```
<!-- markdownlint-enable line-length -->

Despite being shorter, this message to does not help much in finding the actual fault.

Omnipresent type aliasing does not affect only compilation errors but also debugging.
Here is how a breakpoint for the above function looks like in the gdb debugger:

<!-- markdownlint-disable line-length -->
```text
Breakpoint 1, avg_speed<boost::units::heterogeneous_system<boost::units::heterogeneous_system_impl
<boost::units::list<boost::units::heterogeneous_system_dim<boost::units::si::meter_base_unit, boost::units::static_rational<1> >, z
boost::units::dimensionless_type>, boost::units::list<boost::units::dim<boost::units::length_base_dimension,
boost::units::static_rational<1> >, boost::units::dimensionless_type>, boost::units::list<boost::units::scale_list_dim
<boost::units::scale<10, boost::units::static_rational<3> > >, boost::units::dimensionless_type> > >,
boost::units::heterogeneous_system<boost::units::heterogeneous_system_impl<boost::units::list
<boost::units::heterogeneous_system_dim<boost::units::scaled_base_unit<boost::units::si::second_base_unit,
boost::units::scale<60, boost::units::static_rational<2> > >, boost::units::static_rational<1> >,
boost::units::dimensionless_type>, boost::units::list<boost::units::dim<boost::units::time_base_dimension,
boost::units::static_rational<1> >, boost::units::dimensionless_type>, boost::units::dimensionless_type> > > (d=..., t=...) at
velocity_2.cpp:39
39        return d / t;
```
<!-- markdownlint-enable line-length -->

Downcasting facility {#downcasting}
-----------------------------------

To provide much shorter error messages the author of the paper with the help of Richard Smith,
implemented a downcast facility in [[MP-UNITS]]. It allowed converting the following error
log from:

```text
[with T = units::quantity<units::unit<units::dimension<units::exp<units::base_dim_time, 1> >,
std::ratio<1> >, long long int>]
```

Into:

```text
[with T = units::quantity<units::second, long long int>]
```

The downcasting facility provides a type substitution mechanism. It connects a specific
primary class template specialization with a strong type assigned by the user. A simplified
mental model of the facility may be represented as:

```cpp
struct metre : unit<dimension<exp<base_dim_length, 1>>, std::ratio<1, 1, 0>>;
```

In the above example, `metre` is a downcasting target (child class), and a specific `unit`
class template specialization is a downcasting source (base class). The downcasting
facility provides one to one type substitution mechanism. Only one child class can be
created for a specific base class template instantiation.

The downcasting facility is provided through two dedicated types, a concept, and a few
helper template aliases.

```cpp
template<typename BaseType>
struct downcast_base {
  using base_type = BaseType;
  friend auto downcast_guide(downcast_base);
};
```

`units::downcast_base` is a class that implements the CRTP idiom, marks the base of the
downcasting facility with a `base_type` member type, and provides a declaration of the
downcasting ADL friendly (Hidden Friend) entry point member function `downcast_guide`.
An important design point is that this function does not return any specific type in its
declaration. This non-member function is going to be defined in a child class template
`downcast_helper` and will return a target type of the downcasting operation there.

```cpp
template<typename T>
concept Downcastable =
    requires {
      typename T::base_type;
    } &&
    std::derived_from<T, downcast_base<typename T::base_type>>;
```

`units::Downcastable` is a concept that verifies if a type implements and can be used in
a downcasting facility.

```cpp
template<typename Target, Downcastable T>
struct downcast_helper : T {
  friend auto downcast_guide(typename downcast_helper::downcast_base) { return Target(); }
};
```

`units::downcast_helper` is another CRTP class template that provides the implementation
of a non-member friend function of the `downcast_base` class template, which defines the target
type of a downcasting operation. It is used in the following way to define `dimension` and
`unit` types in the library:

```cpp
template<typename Child, Exponent... Es>
struct derived_dimension : downcast_helper<Child, detail::make_dimension_t<Es...>> {};
```

```cpp
template<typename Child, Dimension D>
struct derived_unit<Child, D, R> : downcast_helper<Child, unit<D, ratio<1>>> {};
```

With such CRTP types, the only thing the user has to do to register a new type for the downcasting
facility is to publicly derive from one of those CRTP types and provide its new child type
as the first template parameter of the CRTP type.

```cpp
struct metre : derived_unit<metre, length> {};
```

The above types are used to define the base and target of a downcasting operation. To perform
the actual downcasting operation, a dedicated template alias is provided:

```cpp
template<Downcastable T>
using downcast_target = decltype(detail::downcast_target_impl<T>());
```

`units::downcast_target` is used to obtain the target type of the downcasting operation registered
for a given specialization in a base type.

For example, to determine a downcasted type of a quantity multiply operation, the following
can be done:

```cpp
using dim = dimension_multiply_t<typename U1::dimension, typename U2::dimension>;
using common_rep = decltype(lhs.count() * rhs.count());
using ret = quantity<downcast_target<unit<dim,
                ratio_multiply<typename U1::ratio, typename U2::ratio>>>, common_rep>;
```

`detail::downcast_target_impl` checks if a downcasting target is registered for the specific
base class. If yes, it returns the registered type. Otherwise, it works like a regular identity
type returning a provided base class.

```cpp
namespace detail {

  template<typename T>
  concept has_downcast = requires {
    downcast_guide(std::declval<downcast_base<T>>());
  };

  template<typename T>
  constexpr auto downcast_target_impl()
  {
    if constexpr(has_downcast<T>)
      return decltype(downcast_guide(std::declval<downcast_base<T>>()))();
    else
      return T();
  }

}
```


Template instantiation issues {#template-instantiation-issues}
--------------------------------------------------------------

Errors inside implementation details caused by invalid instantiations.


Concepts {#concepts}
--------------------

???Error messages before instantiating a template rather than a compilation error deeply nested
in the class implementation.??? (Reword)

<!-- markdownlint-disable line-length -->
```text
example.cpp: In instantiation of ‘constexpr units::Velocity avg_speed(D, T)
    [with D = units::quantity<units::kilometre>; T = units::quantity<units::hour>]’:
example.cpp:49:49:   required from here
example.cpp:34:14: error: placeholder constraints not satisfied
    34 |   return d * t;
       |              ^
include/units/dimensions/velocity.h:34:16: note: within ‘template<class T> concept units::Velocity<T>
    [with T = units::quantity<units::unit<units::dimension<units::exp<units::base_dim_length, 1, 1>,
                units::exp<units::base_dim_time, 1, 1> >, units::ratio<3600000, 1> >, double>]’
    34 |   concept Velocity = Quantity<T> && std::same_as<typename T::dimension, velocity>;
       |           ^~~~~~~~
include/stl2/detail/concepts/core.hpp:37:15: note: within ‘template<class T, class U> concept std::same_as<T, U>
    [with T = units::dimension<units::exp<units::base_dim_length, 1, 1>, units::exp<units::base_dim_time, 1, 1> >;
          U = units::velocity]’
    37 |  META_CONCEPT same_as = meta::Same<T, U> && meta::Same<U, T>;
       |               ^~~~~~~
include/meta/meta_fwd.hpp:224:18: note: within ‘template<class T, class U> concept meta::Same<T, U>
    [with T = units::dimension<units::exp<units::base_dim_length, 1, 1>, units::exp<units::base_dim_time, 1, 1> >;
          U = units::velocity]’
   224 |     META_CONCEPT Same =
       |                  ^~~~
include/meta/meta_fwd.hpp:224:18: note: ‘meta::detail::barrier’ evaluated to false
include/meta/meta_fwd.hpp:224:18: note: within ‘template<class T, class U> concept meta::Same<T, U>
    [with T = units::velocity;
          U = units::dimension<units::exp<units::base_dim_length, 1, 1>, units::exp<units::base_dim_time, 1, 1> >]’
include/meta/meta_fwd.hpp:224:18: note: ‘meta::detail::barrier’ evaluated to false
```
<!-- markdownlint-enable line-length -->


Easy to use and hard to abuse {#easy-to-use-hard-to-abuse}
==========================================================

- Consistency with `std::chrono` behavior.
- Clear responsibility of each type (base_dimension -> exp -> dimension -> unit -> quantity).
- Easy to extend with custom dimensions or units.
- Easy to understand error messages thanks to downcast facility and concepts.
- No isolated abstraction for [=systems=] that would complicate implementation and reasoning.


Limiting intermediate quantity value conversions {#limiting-intermediate-value-conversions}
===========================================================================================

Template arguments type deduction {#arguments-type-deduction}
-------------------------------------------------------------

```cpp
template<typename U1, typename Rep1, typename U2, typename Rep2>
constexpr auto avg_speed(units::length<U1, Rep1> d, units::time<U2, Rep2> t)
{
  return d / t;
}
```

[Please note that support for above syntax was removed from [[MP-UNITS]] after the feedback
from Cologne ISO meeting]

Concepts for function arguments {#concepts-for-arguments}
---------------------------------------------------------

```cpp
constexpr auto avg_speed(units::Length auto d, units::Time auto t)
{
  return d / t;
}
```

Concepts for return types {#concepts-for-return-types}
------------------------------------------------------

```cpp
constexpr units::Velocity auto avg_speed(units::Length auto d, units::Time auto t)
{
  return d / t;
}
```

Concept `auto` for intermediate results {#concept-auto-for-intermediate-results}
--------------------------------------------------------------------------------

```cpp
const units::Velocity auto speed = avg_speed(220.km, 2.h);
```


Extensibility {#extensibility}
==============================

The units library should be designed in a way that allows users to easily extend it with
their own units, derived, or even base, dimensions. The C++ Standard Library will most probably
decide to ship with a support for "just" physical units with possible extension to digital
information dimensions and their units. This shouldn't limit the users to the library engine
to address their needs in their domains.

Here are the most important points that have to be addressed by such an engine:
- allows extending the library with new units, derived, and base dimensions,
- provides the same user experience for user-defined entities as for built-in ones,
- no preprocessor macros in the user's interface,
- extensions created by two independent vendors should not collide with each other if they
    address separate domains.


Design decisions {#design-decisions}
====================================

UDL vs multiply syntax {#udl-vs-multiply}
-----------------------------------------

User convenience for implementing derived units
Problems with downcasting


Mixed syntax {#mixed}
---------------------

```cpp
constexpr auto d1 = 1000 * meter(1);
constexpr auto d2 = meter(1000);
constexpr auto d3 = kilo * meter(1);
constexpr auto d4 = 1k*m;
constexpr auto d5 = (k*m)(1);

constexpr auto v1 = quantity<meter/second>(10);
constexpr auto v2 = quantity<m/s>(10);
constexpr auto v3 = meter(10)/second(1);
constexpr auto v4 = meter(10)/second();
constexpr auto v5 = meter(10)/second;
constexpr auto v6 = m(10)/s;
constexpr auto v7 = (m/s)(10);
constexpr auto v8 = 10m/s;
```

NTTP usage {#nttp-usage}
------------------------

There are a few points in the physical units domain design that could benefit from Non-Type
Template Parameters usage. One of the most apparent cases here is `ratio`. A classical
implementation of such a class template looks like this:

```cpp
template<intmax_t Num, intmax_t Den = 1>
struct ratio {
  static constexpr intmax_t num = Num * static_sign<Den>::value / static_gcd<Num, Den>::value;
  static constexpr intmax_t den = static_abs<Den>::value / static_gcd<Num, Den>::value;
  using type = ratio<num, den>;
};
```

Besides, it provides a few utilities to do operations on such types:

```cpp
namespace detail {
  template<typename R1, typename R2>
  struct ratio_multiply_impl {
  private:
    static constexpr intmax_t gcd1 = static_gcd<R1::num, R2::den>::value;
    static constexpr intmax_t gcd2 = static_gcd<R2::num, R1::den>::value;
  public:
    using type = ratio<safe_multiply<(R1::num / gcd1), (R2::num / gcd2)>::value,
                       safe_multiply<(R1::den / gcd2), (R2::den / gcd1)>::value>;
    static constexpr intmax_t num = type::num;
    static constexpr intmax_t den = type::den;
  };
}
template<typename R1, typename R2>
using ratio_multiply = detail::ratio_multiply_impl<R1, R2>::type;
```

Usage examples of such an approach looks as follows:

```cpp
struct yard : derived_unit<yard, length, ratio<9'144, 10'000>> {};
struct foot : derived_unit<foot, length, ratio_multiply<ratio<1, 3>, yard::ratio>> {};
struct inch : derived_unit<inch, length, ratio_multiply<ratio<1, 12>, foot::ratio>> {};
struct mile : derived_unit<mile, length, ratio_multiply<ratio<1'760>, yard::ratio>> {};
```

With NTTP the implementation and usage of the `ratio` are much easier:

```cpp
struct ratio {
  std::intmax_t num;
  std::intmax_t den;

  explicit constexpr ratio(std::intmax_t n, std::intmax_t d = 1) :
    num(n * (d < 0 ? -1 : 1) / std::gcd(n, d)),
    den(abs(d) / std::gcd(n, d))
  {
  }

  [[nodiscard]] constexpr bool operator==(const ratio&) = default;

  [[nodiscard]] friend constexpr ratio operator*(const ratio& lhs, const ratio& rhs)
  {
    const std::intmax_t gcd1 = std::gcd(lhs.num, rhs.den);
    const std::intmax_t gcd2 = std::gcd(rhs.num, lhs.den);
    return ratio(safe_multiply(lhs.num / gcd1, rhs.num / gcd2),
                 safe_multiply(lhs.den / gcd2, rhs.den / gcd1));
  }

  [[nodiscard]] friend consteval ratio operator*(std::intmax_t n, const ratio& rhs)
  {
    return ratio(n) * rhs;
  }

  [[nodiscard]] friend consteval ratio operator*(const ratio& lhs, std::intmax_t n)
  {
    return lhs * ratio(n);
  }
};
```

```cpp
// US customary units
struct yard : derived_unit<yard, length, ratio(9'144, 10'000)> {};
struct foot : derived_unit<foot, length, yard::ratio / 3> {};
struct inch : derived_unit<inch, length, foot::ratio / 12> {};
struct mile : derived_unit<mile, length, 1'760 * yard::ratio> {};
```


Relative vs absolute quantity {#relative-vs-absolute}
-----------------------------------------------------

One of the most critical aspects of the physical units library is to understand what a
[=quantity=] is? An absolute or relative value? For most dimensions only relative values
have sense. For example:
- Where are absolute 123 meters?
- If I am sitting in a moving train, is my velocity == 0?
- Is my velocity == 0 when the train stops?

However, for some dimensions like temperature, absolute values are really needed. For
example, how much is `0 ℃ + 0 ℃`? Is it `0 ℃` or `0 ℃` or `273.15 ℃`? Yes, the repeated
value of `0 ℃` is not an error here ;-) Actually, all of the answers are right:
- Two (absolute) temperatures:

    ```text
    0 ℃ + 0 ℃ = 273.15 K + 273.15 K = 546.30 K = 273.15 ℃
    ```

- An (absolute) temperature and a (relative) temperature interval:

    ```text
    0 ℃ + 0 ℃ = 273.15 K + 0 K = 273.15 K = 0 ℃
    ```

- Two (relative) temperature intervals:

    ```text
    0 ℃ + 0 ℃ = 0 K + 0 K = 0 K = 0 ℃
    ```

As proven above, it is a complex and a pretty hard problem. The average user of the library
will probably not be able to distinguish between different kinds of quantities. This is
why it was decided that only relative quantity values will be modeled by the library.
Moreover, providing support for only relative quantities of other temperature units than
Kelvin will probably still be misused by the users. This is why it was decided to support
only Kelvins as built-in temperature units and provide verbose non-member utility
functions for conversions between different kinds  of temperature values and their units.


Open questions {#open-questions}
================================

Should we support [=systems=] as a separate type {#systems-support}
---------------------------------------------------------------

US Customary System has the same dimensions and most of the units as SI with the differences
scoped mostly only in length and mass units and derived dimensions using those. It is much
simpler to use the common definitions of such dimensions and just provide units dedicated to
such a system together with SI (i.e. meters and miles).

Even systems that seem to be totally isolated from typical SI uses cases like
`coffee/milk/water/sugar` system at some point will probably need time, volume, and other SI
dimensions too.

Boost.Units uses [=systems=] mostly to provide the capability of having a different
[=base unit=] for a dimension to limit intermediate conversions while passing quantities
as vocabulary types in the interfaces. Usage of templates constrained with concepts for
generic algorithms and concrete types for domain-specific need addresses this area easily.

(Example of a generic interface i.e. avg_speed with miles)

(Example of a domain-specific interface i.e. eV)


Compatibility with `std::chrono::duration` {#duration-compatibility}
--------------------------------------------------------------------


Should we provide integral UDLs {#integral-udl}
-----------------------------------------------

- Yes, as is (always both integral and floating-point for all units).
- Yes, but with floating `Rep`.
- Yes, but only for specific units like a `bit`, `byte`, etc. where floating-point types do
    not have much sense (no floating-point UDLs).
- No, just use floating-point UDLs for all (no integral UDLs).


Should we provide `seconds<int>` or stay with `quantity<second, int>`? {#seconds-int}
-------------------------------------------------------------------------------------


Should we provide support for dimensionless quantities? {#dimensionless-quantities}
-----------------------------------------------------------------------------------


Impact on the Standard {#impact}
================================


Implementation Experience {#implementation}
===========================================

The author of this document implemented `mp-units` [[MP-UNITS]] library, where he tested
different ideas and proved the implementability of the features described in the paper. The
library framework consists of a few concepts: [=quantities=], [=units=], [=dimensions=],
and their exponents. From the user's point of view, the most important is a [=quantity=].

[=Quantity=] is a precise amount of a unit for a specified dimension with a specific representation:

```cpp
units::quantity<units::kilometre, double> d1(123);
auto d2 = 123km;    // units::quantity<units::kilometre, std::int64_t>
```

There are C++ concepts provided for each such quantity type:

```cpp
template<typename T>
concept Length = QuantityOf<T, length>;
```

With these concepts, we can easily write a function template:

```cpp
constexpr units::Velocity auto avg_speed(units::Length auto d, units::Time auto t)
{
  return d / t;
}
```

This template function can be used in the following way:

```cpp
const units::quantity<units::kilometre> d(220);
const units::quantity<units::hour> t(2);
const units::Velocity auto kmph = units::quantity_cast<units::kilometre_per_hour>(avg_speed(d, t));
std::cout << kmph.count() << " km/h\n";

const units::Velocity auto speed = avg_speed(140.mi, 2.h);
assert(speed.count() == 70);
std::cout << units::quantity_cast<units::mile_per_hour>(speed).count() << " mph\n";
```

This guarantees that no intermediate conversions are being made, and the output binary is as
effective as implementing the function with `double`s.

Additionally, thanks to the extensive usage of the C++ concepts and the downcasting facility,
the library provides an excellent user experience. The error message for type aliases would
look like:

```text
[with D = units::quantity<units::unit<units::dimension<units::exp<units::base_dim_length, 1, 1>,
                units::exp<units::base_dim_time, 1, -1> >, units::ratio<5, 18> >, double>]
```

Yet, thanks to downcast facility, the actual error message is:

```text
[with D = units::quantity<units::kilometre_per_hour, double>]
```

The breakpoint in the debugger became readable as well:

```text
Breakpoint 1, avg_speed<units::quantity<units::kilometre, double>,
                        units::quantity<units::hour, double> >
(d=..., t=...) at velocity.cpp:31
31      return d / t;
```

Moreover, it is really easy to extend the library with custom units, derived units, and
base dimensions. For example, if the user wants to provide a custom `digital information`
base dimension and new units based on it, only minimal code is required:

```cpp
#include <units/quantity.h>

using namespace units;

// custom base dimension
struct base_dim_digital_information {
  static constexpr const char* value = "digital information";
};

// custom derived dimension and its concept
struct digital_information : derived_dimension<digital_information,
                                               units::exp<base_dim_digital_information, 1>> {};

template<typename T>
concept DigitalInformation = QuantityOf<T, digital_information>;

// custom units and their units
struct bit : derived_unit<bit, digital_information> {};
struct byte : derived_unit<byte, digital_information, ratio<8>> {};

inline namespace literals {
  constexpr auto operator""_b(unsigned long long l) { return quantity<bit, std::int64_t>(l); }
  constexpr auto operator""_b(long double l) { return quantity<bit, long double>(l); }

  constexpr auto operator""_B(unsigned long long l) { return quantity<byte, std::int64_t>(l); }
  constexpr auto operator""_B(long double l) { return quantity<byte, long double>(l); }
}

// unit tests
static_assert(1_B == 8_b);
```

Polls {#polls}
==============

1. Do we want a physical units library in the C++ standard?
2. Should we provide the support for some [=off-system units=] (i.e. eV)?
3. Do we want to have support for digital information [=dimensions=] and its
    [=multiple of a unit|prefixes=] in the initial version of the library?
4. Do we prefer UDL, multiply, or mixed syntax for units?
5. Do we like the concept-based approach to prevent truncation?
6. Do we like a downcasting facility or do we want to wait for other solutions (strong types
    in the language, better compiler errors, ...)?
7. Do we prefer NTTP usage for `ratio` and `exp`?
8. Do we want to require explicit casts between different units of the same dimension, or
    do we allow `chrono`-like implicit conversions (floating-point representation and
    non-truncating integer conversions)?
9. Do we agree with Kelvins only support for temperature and verbose conversion functions
    for other [=units=] and absolute temperatures?
10. Which option of UDLs do we prefer ([[#integral-udl]])?
11. Should we provide `seconds<int>` or stay with `quantity<second, int>`?
12. Should we provide support for dimensionless quantities?
13. Should American spelling be provided? (`meter` vs. `metre`, `ton` vs. `tonne`, ...)
14. Do we want to introduce a dedicated system type?


Acknowledgments {#acknowledgements}
===================================

Special thanks and recognition goes to [Epam Systems](http://www.epam.com) for supporting my
membership in the ISO C++ Committee and the production of this proposal.

I would also like to thank Jan Sende for his contributions to the `mp-units` library and
this document.

<pre class=biblio>
{
    "ISO_80000-1": {
        "href": "https://www.iso.org/standard/30669.html",
        "title": "Quantities and units - Part 1: General",
        "publisher": "ISO"
    },
    "MARS_ORBITER": {
        "href": "https://en.wikipedia.org/wiki/Mars_Climate_Orbiter",
        "title": "Mars Climate Orbiter",
        "publisher": "Wikipedia"
    },
    "COLUMBUS": {
        "href": "https://en.wikipedia.org/wiki/Christopher_Columbus",
        "title": "Christopher Columbus",
        "publisher": "Wikipedia"
    },
    "GIMLI_GLIDER": {
        "href": "https://en.wikipedia.org/wiki/Gimli_Glider",
        "title": "Gimli Glider",
        "publisher": "Wikipedia"
    },
    "CLARENCE": {
        "authors": [ "Steve Chawkins" ],
        "href": "https://www.latimes.com/archives/la-xpm-2001-feb-09-me-23253-story.html",
        "title": "Mismeasure for Measure",
        "publisher": "Los Angeles Times"
    },
    "DISNEY": {
        "href": "https://web.archive.org/web/20040209033827/http://www.olc.co.jp/news/20040121_01en.html",
        "title": "Cause of the Space Mountain Incident Determined at Tokyo Disneyland Park",
        "publisher": "Oriental Land Co., Ltd."
    },
    "FLIGHT_6316": {
        "href": "https://ntsb.gov/news/press-releases/Pages/Korean_Air_Flight_6316_MD-11_Shanghai_China_-_April_15_1999.aspx",
        "title": "Korean Air Flight 6316 MD-11, Shanghai, China - April 15, 1999",
        "publisher": "National Transportation Safety Board"
    },
    "WILD_RICE": {
        "href": "https://www.bizjournals.com/eastbay/stories/2001/07/09/focus3.html",
        "title": "Manufacturers, exporters think metric",
        "publisher": "San Francisco Business Times"
    },
    "MP-UNITS": {
        "authors": [ "Mateusz Pusz" ],
        "href": "https://github.com/mpusz/units",
        "title": "mp-units"
    },
    "BOOST.UNITS": {
        "authors": [ "Steven Watanabe", "Matthias C. Schabel" ],
        "href": "https://www.boost.org/doc/libs/1_70_0/doc/html/boost_units.html",
        "title": "Boost.Units",
        "publisher": "Boost"
    },
    "CPPNOW17-UNITS": {
        "authors": [ "Steven Watanabe" ],
        "href": "https://github.com/swatanabe/cppnow17-units",
        "title": "cppnow17-units"
    },
    "PHYSUNITS-CT-CPP11": {
        "authors": [ "Martin Moene" ],
        "href": "https://github.com/martinmoene/PhysUnits-CT-Cpp11",
        "title": "PhysUnits-CT-Cpp11"
    },
    "NIC_UNITS": {
        "authors": [ "Nic Holthaus" ],
        "href": "https://github.com/nholthaus/units",
        "title": "units"
    },
    "BRYAN_UNITS": {
        "authors": [ "Bryan St. Amour" ],
        "href": "https://github.com/bstamour/units",
        "title": "units"
    },
    "BENRI": {
        "authors": [ "Jan Sende" ],
        "href": "https://github.com/jansende/benri",
        "title": "benri"
    },
    "MIKEFORD3_UNITS": {
        "authors": [ "Michael Ford" ],
        "href": "https://github.com/mikeford3/units",
        "title": "units"
    }

}
</pre>
